<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>–ü–∞—Ä–æ–¥–∏—è: "–ë–æ–π—Ü—ã –Ω–∞ –õ—É–∂–∞–π–∫–µ" ‚Äî 2D HTML</title>
<style>
  html,body{height:100%;margin:0;background:#0b1220;color:#fff;font-family:Inter,Arial,system-ui}
  #ui{position:fixed;left:0;right:0;top:0;padding:8px;display:flex;justify-content:space-between;pointer-events:none}
  #scorePanel{pointer-events:auto;background:rgba(0,0,0,0.35);padding:6px 10px;border-radius:8px;font-size:16px}
  canvas{display:block;width:100%;height:100%;touch-action:none}
  .controls{position:fixed;left:12px;bottom:12px;display:flex;gap:8px;pointer-events:auto}
  .ctl{width:72px;height:72px;border-radius:12px;background:rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;font-size:26px}
  .shoot{position:fixed;right:12px;bottom:12px;width:84px;height:84px;border-radius:999px;background:rgba(255,80,80,0.14);display:flex;align-items:center;justify-content:center;font-size:20px;pointer-events:auto}
  .small{position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.35);padding:6px 8px;border-radius:8px}
  .hint{position:fixed;left:50%;transform:translateX(-50%);bottom:110px;background:rgba(0,0,0,0.25);padding:8px 12px;border-radius:8px;font-size:13px}
</style>
</head>
<body>
  <div id="ui">
    <div id="scorePanel">–û—á–∫–∏: <span id="score">0</span></div>
    <div class="small" id="time">0s</div>
  </div>
  <canvas id="game"></canvas>

  <div class="controls">
    <div class="ctl" id="left">‚óÄ</div>
    <div class="ctl" id="up">‚ñ≤</div>
    <div class="ctl" id="down">‚ñº</div>
    <div class="ctl" id="right">‚ñ∂</div>
  </div>
  <div class="shoot" id="shoot">üí•</div>
  <div class="hint">–ü–∞—Ä–æ–¥–∏—è "–ë–æ–π—Ü—ã –Ω–∞ –õ—É–∂–∞–π–∫–µ" ‚Äî —Å—Ç—Ä–µ–ª—è–π –≤ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–æ–≤, —Å–æ–±–∏—Ä–∞–π —Å—É–Ω–¥—É–∫–∏.</div>

<script>
/*
  –ü—Ä–æ—Å—Ç–∞—è 2D –ø–∞—Ä–æ–¥–∏—è, –º–æ–±–∏–ª—å–Ω—ã–π-–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π, single-file.
  - –î–≤–∏–∂–µ–Ω–∏–µ —Å—Ç—Ä–µ–ª–∫–∞–º–∏ (–∫–Ω–æ–ø–∫–∏) ‚Äî –∏ —É–¥–µ—Ä–∂–∞–Ω–∏–µ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è
  - –ö–Ω–æ–ø–∫–∞ –æ–≥–Ω—è ‚Äî —Å—Ç—Ä–µ–ª—è–µ—Ç –ø—É–ª—å–µ–π
  - –ò–ò-–ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∏ –ø–∞—Ç—Ä—É–ª–∏—Ä—É—é—Ç –∏ —Å—Ç—Ä–µ–ª—è—é—Ç
  - –°—É–Ω–¥—É–∫–∏ (collectibles) –¥–∞—é—Ç –æ—á–∫–∏
  - –î–∏–∑–∞–π–Ω: –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ —Å–ø—Ä–∞–π—Ç—ã —Ä–∏—Å—É—é—Ç—Å—è –Ω–∞ canvas

  –ê–≤—Ç–æ—Ä—Å–∫–∞—è –∑–∞–º–µ—Ç–∫–∞: —ç—Ç–æ –ø–∞—Ä–æ–¥–∏—è, –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –∞—Ä—Ç–∏—Ñ–∞–∫—Ç—ã/–±—Ä–µ–Ω–¥—ã.
*/
(function(){
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W = 1, H = 1;
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth * dpr);
    H = Math.floor(window.innerHeight * dpr);
    canvas.width = W; canvas.height = H;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // Game world
  const world = { w: 1200, h: 700 }; // virtual world size; we'll fit to canvas
  const toScreen = (x,y)=>{
    // center world in screen
    const scale = Math.min(window.innerWidth / world.w, window.innerHeight / world.h);
    const ox = (window.innerWidth - world.w*scale)/2;
    const oy = (window.innerHeight - world.h*scale)/2;
    return { x: ox + x*scale, y: oy + y*scale, scale };
  };

  // Entities
  function makePlayer(){ return {
    x: world.w/2, y: world.h/2, r: 22, angle:0, speed: 220, bullets:[], reload: 0.25, cooldown: 0,
    color: '#ffcc55', hp: 5
  }}
  function makeEnemy(x,y){ return { x,y,r:20,angle:0,speed:100,bullets:[],cooldown:Math.random()*2+1,color:'#66ccff',hp:3,dir:Math.random()*Math.PI*2 } }
  function makeChest(x,y){ return {x,y,r:14,claimed:false} }

  const player = makePlayer();
  const enemies = [ makeEnemy(200,150), makeEnemy(900,300), makeEnemy(400,520) ];
  const chests = [ makeChest(250,350), makeChest(800,180), makeChest(600,420) ];
  let score = 0; let timeStart = performance.now();

  // UI refs
  const scoreEl = document.getElementById('score');
  const timeEl = document.getElementById('time');

  // Controls: support pointer hold
  const state = { left:false, right:false, up:false, down:false, shoot:false };
  function bindBtn(id, key){
    const el = document.getElementById(id);
    el.addEventListener('pointerdown', e=>{ e.preventDefault(); state[key] = true; el.setPointerCapture && el.setPointerCapture(e.pointerId); });
    el.addEventListener('pointerup', e=>{ e.preventDefault(); state[key] = false; try{ el.releasePointerCapture(e.pointerId); }catch(_){} });
    el.addEventListener('pointercancel', e=>{ state[key]=false; });
    // also prevent context menu on long press
    el.addEventListener('contextmenu', e=>e.preventDefault());
  }
  bindBtn('left','left'); bindBtn('right','right'); bindBtn('up','up'); bindBtn('down','down');
  const shootBtn = document.getElementById('shoot');
  shootBtn.addEventListener('pointerdown', e=>{ e.preventDefault(); state.shoot = true; shootBtn.setPointerCapture && shootBtn.setPointerCapture(e.pointerId); });
  shootBtn.addEventListener('pointerup', e=>{ state.shoot = false; try{ shootBtn.releasePointerCapture(e.pointerId); }catch(_){} });
  shootBtn.addEventListener('pointercancel', e=>{ state.shoot=false; });

  // helper
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

  // bullets global array
  const bullets = [];

  function spawnBullet(x,y,angle,owner){ bullets.push({x,y,dx:Math.cos(angle)*620,dy:Math.sin(angle)*620,owner,ttl:2}); }

  // simple collision
  function circleHit(a,b){ const dx=a.x-b.x, dy=a.y-b.y; const r = (a.r||0)+(b.r||0); return dx*dx+dy*dy <= r*r; }

  // draw functions (simple shapes)
  function drawPlayer(p,ctxLocal){ ctxLocal.save(); ctxLocal.translate(p.x,p.y); ctxLocal.rotate(p.angle);
    ctxLocal.fillStyle = p.color; ctxLocal.beginPath(); ctxLocal.arc(0,0,p.r,0,Math.PI*2); ctxLocal.fill();
    // eye
    ctxLocal.fillStyle='#222'; ctxLocal.beginPath(); ctxLocal.arc(p.r*0.4,-p.r*0.25,6,0,Math.PI*2); ctxLocal.fill();
    // gun barrel
    ctxLocal.fillStyle='#333'; ctxLocal.fillRect(p.r-4,-6,18,12);
    ctxLocal.restore(); }
  function drawEnemy(e,ctxLocal){ ctxLocal.save(); ctxLocal.translate(e.x,e.y); ctxLocal.rotate(e.angle);
    ctxLocal.fillStyle = e.color; ctxLocal.beginPath(); ctxLocal.arc(0,0,e.r,0,Math.PI*2); ctxLocal.fill();
    ctxLocal.fillStyle='#111'; ctxLocal.beginPath(); ctxLocal.arc(e.r*0.35,-e.r*0.2,5,0,Math.PI*2); ctxLocal.fill();
    ctxLocal.restore(); }
  function drawChest(c,ctxLocal){ ctxLocal.save(); ctxLocal.translate(c.x,c.y);
    ctxLocal.fillStyle = c.claimed? '#666' : '#aa8833'; ctxLocal.fillRect(-c.r,-c.r,c.r*2,c.r*2);
    ctxLocal.fillStyle='#333'; ctxLocal.fillRect(-c.r+4,-c.r+6,c.r*2-8,6);
    ctxLocal.restore(); }

  // Tests / assertions ‚Äî basic runtime checks
  console.assert(typeof canvas !== 'undefined','Test: canvas exists');
  console.assert(typeof ctx !== 'undefined','Test: canvas context exists');
  console.assert(player && enemies.length>0, 'Test: entities created');

  // Game loop
  let last = performance.now();
  function step(now){
    const dt = Math.min(0.05,(now-last)/1000); last = now;
    update(dt); render();
    requestAnimationFrame(step);
  }

  function update(dt){
    // time
    const elapsed = Math.floor((nowTime())/1000);
    timeEl.textContent = elapsed + 's';

    // player movement
    let vx=0, vy=0;
    if(state.left) vx -= 1; if(state.right) vx +=1; if(state.up) vy -=1; if(state.down) vy +=1;
    if(vx!==0 || vy!==0){ const len = Math.hypot(vx,vy); vx = vx/len; vy = vy/len; player.x += vx * player.speed * dt; player.y += vy * player.speed * dt; player.angle = Math.atan2(vy,vx); }
    // clamp
    player.x = clamp(player.x, 30, world.w-30); player.y = clamp(player.y,30, world.h-30);

    // shooting
    player.cooldown -= dt; if(state.shoot && player.cooldown <= 0){ player.cooldown = player.reload; // spawn bullet from tip of gun
      const bx = player.x + Math.cos(player.angle)*(player.r+16); const by = player.y + Math.sin(player.angle)*(player.r+16); spawnBullet(bx,by,player.angle,'player'); }

    // bullets update
    for(let i=bullets.length-1;i>=0;i--){ const b = bullets[i]; b.x += b.dx*dt; b.y += b.dy*dt; b.ttl -= dt; if(b.ttl<=0 || b.x<0 || b.x>world.w || b.y<0 || b.y>world.h){ bullets.splice(i,1); continue; }
      // collisions
      if(b.owner==='player'){
        for(let j=enemies.length-1;j>=0;j--){ const e=enemies[j]; if(circleHit({x:b.x,y:b.y,r:6}, e)){ e.hp -=1; bullets.splice(i,1); if(e.hp<=0){ score += 20; scoreEl.textContent = score; enemies.splice(j,1); } break; } }
      } else {
        if(circleHit({x:b.x,y:b.y,r:6}, player)){
          player.hp -=1; bullets.splice(i,1); if(player.hp<=0){ // game over reset
            resetGame(); return; }
        }
      }
    }

    // enemies AI: simple wander + occasional shoot
    for(const e of enemies){
      e.dir += (Math.random()-0.5)*0.5*dt; e.x += Math.cos(e.dir)*e.speed*dt; e.y += Math.sin(e.dir)*e.speed*dt;
      e.x = clamp(e.x,30,world.w-30); e.y = clamp(e.y,30,world.h-30);
      // face player
      const ang = Math.atan2(player.y - e.y, player.x - e.x); e.angle = ang;
      e.cooldown = (e.cooldown||0) - dt;
      if(e.cooldown <= 0){ e.cooldown = Math.random()*2+1; // shoot at player
        const bx = e.x + Math.cos(ang)*(e.r+12); const by = e.y + Math.sin(ang)*(e.r+12); spawnBullet(bx,by,ang,'enemy'); }
    }

    // chests
    for(let i=chests.length-1;i>=0;i--){ const c = chests[i]; if(!c.claimed && circleHit(player,c)){ c.claimed = true; score += 10; scoreEl.textContent = score; } }

    // small respawn logic
    if(enemies.length < 2 && Math.random() < 0.02){ enemies.push(makeEnemy(Math.random()*(world.w-200)+100, Math.random()*(world.h-200)+100)); }
  }

  function render(){
    // clear
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // draw background grass (pattern)
    const grad = ctx.createLinearGradient(0,0,0,window.innerHeight); grad.addColorStop(0,'#083020'); grad.addColorStop(1,'#0b2b1a'); ctx.fillStyle = grad; ctx.fillRect(0,0,window.innerWidth,window.innerHeight);

    // compute scale and offset
    const scale = Math.min(window.innerWidth/world.w, window.innerHeight/world.h);
    const ox = (window.innerWidth - world.w*scale)/2;
    const oy = (window.innerHeight - world.h*scale)/2;

    ctx.save(); ctx.translate(ox,oy); ctx.scale(scale,scale);

    // draw chests
    for(const c of chests){ drawChest(c,ctx); }
    // draw enemies
    for(const e of enemies){ drawEnemy(e,ctx); }
    // draw player
    drawPlayer(player,ctx);
    // draw bullets
    for(const b of bullets){ ctx.fillStyle = (b.owner==='player')? '#ffd866' : '#88d2ff'; ctx.beginPath(); ctx.arc(b.x,b.y,6,0,Math.PI*2); ctx.fill(); }

    ctx.restore();
  }

  function nowTime(){ return (performance.now() - timeStart)/1000; }

  function resetGame(){ score = 0; scoreEl.textContent = score; player.x = world.w/2; player.y = world.h/2; player.hp = 5; enemies.length = 0; enemies.push(makeEnemy(200,150)); enemies.push(makeEnemy(900,300)); chests.forEach(c=>c.claimed=false); bullets.length = 0; }

  // start loop
  requestAnimationFrame(step);

  // expose for debugging
  window.__PARODY = { player, enemies, chests, bullets, resetGame };

})();
</script>
</body>
</html>
d*100)/100)+'x';

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // Helpful: allow tap-to-teleport lateral for quick testing on desktop
    renderer.domElement.addEventListener('click', (e)=>{
      const nx = (e.clientX / window.innerWidth) * 2 - 1;
      state.targetX = Math.max(-3.5, Math.min(3.5, nx * 4));
    });

    // Simple orient hint: tilt device to look around
    if(window.DeviceOrientationEvent){ window.addEventListener('deviceorientation', (ev)=>{
      if(ev.gamma!=null){ camera.rotation.z = THREE.MathUtils.degToRad(ev.gamma*0.07); }
    }); }

    // touch jump on double-tap
    let lastTap = 0;
    renderer.domElement.addEventListener('touchend', (e)=>{ const t = performance.now(); if(t - lastTap < 300) jump(); lastTap = t; });

    // expose debug for console tweaking
    window.__GAME = { scene, player, obstacles, collectibles };

  })();
  </script>
</body>
</html>

